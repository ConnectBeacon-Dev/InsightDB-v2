#!/usr/bin/env python3
"""
Query Plan Executor

This module provides execution capabilities for query plans generated by the IndustrialQueryPlanner.
It handles multi-step query execution, dependency management, and result aggregation.

Usage:
    from src.company_index.query_plan_executor import QueryPlanExecutor
    
    executor = QueryPlanExecutor(search_api)
    result = executor.execute_plan(query_plan)
"""

import logging
import re
from typing import Dict, List, Any, Optional, Set
from dataclasses import asdict

# Import query planning components
try:
    from src.query_engine.build_query_domain import QueryPlan, SubQuery, QueryType, Priority
except ImportError:
    from src.query_engine.build_query_domain import QueryPlan, SubQuery, QueryType, Priority

# Set up logging
logger = logging.getLogger(__name__)

class ExecutionContext:
    """Manages context and intermediate results during query plan execution."""
    
    def __init__(self):
        self.step_results: Dict[str, List[Dict]] = {}
        self.intermediate_data: Dict[str, Any] = {}
        self.execution_metadata: Dict[str, Any] = {}
        self.company_filters: Dict[str, Any] = {}
    
    def store_step_result(self, step_id: str, results: List[Dict], metadata: Dict = None):
        """Store results from a completed step."""
        self.step_results[step_id] = results
        if metadata:
            self.execution_metadata[step_id] = metadata
        logger.debug(f"Stored {len(results)} results for step: {step_id}")
    
    def get_context_for_step(self, step_id: str, dependencies: List[str]) -> Dict[str, Any]:
        """Get context data needed for executing a step."""
        context = {
            'previous_results': {},
            'filters': self.company_filters.copy(),
            'metadata': {}
        }
        
        for dep_id in dependencies:
            if dep_id in self.step_results:
                context['previous_results'][dep_id] = self.step_results[dep_id]
                if dep_id in self.execution_metadata:
                    context['metadata'][dep_id] = self.execution_metadata[dep_id]
        
        return context
    
    def get_all_company_ids(self) -> Set[str]:
        """Get all unique company IDs from stored results."""
        company_ids = set()
        for results in self.step_results.values():
            for result in results:
                if 'company_ref_no' in result:
                    company_ids.add(result['company_ref_no'])
        return company_ids

class ResultAggregator:
    """Handles intelligent aggregation of results from multiple query steps."""
    
    @staticmethod
    def intersect_companies(result_sets: List[List[Dict]]) -> List[Dict]:
        """Find companies that appear in all result sets."""
        if not result_sets:
            return []
        
        if len(result_sets) == 1:
            return result_sets[0]
        
        # Get company IDs from first set
        company_ids = {r['company_ref_no'] for r in result_sets[0] if 'company_ref_no' in r}
        
        # Intersect with other sets
        for result_set in result_sets[1:]:
            set_ids = {r['company_ref_no'] for r in result_set if 'company_ref_no' in r}
            company_ids &= set_ids
        
        # Return companies from first set that are in intersection
        return [r for r in result_sets[0] if r.get('company_ref_no') in company_ids]
    
    @staticmethod
    def union_products(company_results: List[Dict], product_results: List[Dict]) -> List[Dict]:
        """Combine company and product information."""
        # Create a mapping of company_ref_no to company info
        company_map = {r['company_ref_no']: r for r in company_results if 'company_ref_no' in r}
        
        # Enhance product results with company information
        enhanced_results = []
        for product in product_results:
            if 'company_ref_no' in product and product['company_ref_no'] in company_map:
                # Merge company and product information
                enhanced = company_map[product['company_ref_no']].copy()
                enhanced.update(product)
                enhanced_results.append(enhanced)
        
        return enhanced_results
    
    @staticmethod
    def rank_by_relevance(results: List[Dict], original_query: str) -> List[Dict]:
        """Re-rank combined results by relevance to original query."""
        query_terms = set(original_query.lower().split())
        
        def calculate_relevance(result: Dict) -> float:
            score = 0.0
            text_fields = ['company_name', 'core_expertise', 'industry_domain', 'products']
            
            for field in text_fields:
                if field in result and result[field]:
                    field_text = str(result[field]).lower()
                    matches = sum(1 for term in query_terms if term in field_text)
                    score += matches / len(query_terms)
            
            return score
        
        # Sort by relevance score (descending)
        return sorted(results, key=calculate_relevance, reverse=True)

class QueryPlanExecutor:
    """Executes query plans with dependency management and result aggregation."""
    
    def __init__(self, search_api):
        """
        Initialize the query plan executor.
        
        Args:
            search_api: CompanySearchAPI instance for executing searches
        """
        self.search_api = search_api
        self.context = ExecutionContext()
        self.aggregator = ResultAggregator()
    
    def execute_plan(self, query_plan: QueryPlan) -> Dict[str, Any]:
        """
        Execute a complete query plan with dependency management.
        
        Args:
            query_plan: The query plan to execute
            
        Returns:
            Dict containing results, execution steps, and metadata
        """
        logger.info(f"Executing query plan: {query_plan.plan_type.value} with {len(query_plan.sub_queries)} steps")
        
        execution_steps = []
        
        try:
            # Get execution format from query planner if available
            if hasattr(self.search_api, 'query_planner') and self.search_api.query_planner:
                execution_format = self.search_api.query_planner.format_plan_for_execution(query_plan)
                execution_batches = execution_format['execution_batches']
            else:
                # Fallback: execute in order specified
                execution_batches = [[sq.id] for sq in query_plan.sub_queries]
            
            # Execute in batches based on dependencies
            for batch_idx, batch in enumerate(execution_batches):
                logger.debug(f"Executing batch {batch_idx + 1}/{len(execution_batches)}: {batch}")
                
                for sub_query_id in batch:
                    sub_query = next((sq for sq in query_plan.sub_queries if sq.id == sub_query_id), None)
                    if not sub_query:
                        logger.warning(f"Sub-query not found: {sub_query_id}")
                        continue
                    
                    # Get context for this step
                    context = self.context.get_context_for_step(sub_query_id, sub_query.dependencies)
                    
                    # Execute sub-query
                    step_results = self.execute_sub_query(sub_query, context)
                    
                    # Store results
                    self.context.store_step_result(sub_query_id, step_results)
                    
                    execution_steps.append({
                        'step_id': sub_query_id,
                        'query': sub_query.query,
                        'results_count': len(step_results),
                        'dependencies': sub_query.dependencies,
                        'reasoning': sub_query.reasoning
                    })
                    
                    logger.info(f"Step {sub_query_id} completed: {len(step_results)} results")
            
            # Aggregate final results
            final_results = self.aggregate_final_results(query_plan)
            
            return {
                'results': final_results,
                'query_plan': asdict(query_plan),
                'execution_steps': execution_steps,
                'metadata': {
                    'planning_used': True,
                    'confidence': query_plan.confidence,
                    'total_steps': len(execution_steps),
                    'plan_type': query_plan.plan_type.value,
                    'final_results_count': len(final_results)
                }
            }
            
        except Exception as e:
            logger.error(f"Error executing query plan: {e}")
            # Return partial results if available
            return {
                'results': [],
                'query_plan': asdict(query_plan),
                'execution_steps': execution_steps,
                'metadata': {
                    'planning_used': True,
                    'confidence': 0.0,
                    'error': str(e),
                    'total_steps': len(execution_steps)
                }
            }
    
    def execute_sub_query(self, sub_query: SubQuery, context: Dict) -> List[Dict]:
        """
        Execute a single sub-query with intelligent parameter mapping.
        
        Args:
            sub_query: The sub-query to execute
            context: Context from previous steps
            
        Returns:
            List of search results
        """
        logger.debug(f"Executing sub-query: {sub_query.id} - {sub_query.query}")
        
        try:
            # Handle different types of sub-queries
            if sub_query.id.startswith('scale_definition'):
                return self.execute_scale_definition(sub_query, context)
            elif sub_query.id.startswith('company_filter') or sub_query.id.startswith('filter_'):
                return self.execute_filter_query(sub_query, context)
            elif sub_query.id.startswith('product_listing'):
                return self.execute_product_listing(sub_query, context)
            elif sub_query.id.startswith('combine_'):
                return self.execute_combination_query(sub_query, context)
            else:
                # Default: map to search parameters and execute
                search_params = self.map_subquery_to_search_params(sub_query, context)
                return self.search_api.search(**search_params)
                
        except Exception as e:
            logger.error(f"Error executing sub-query {sub_query.id}: {e}")
            return []
    
    def execute_scale_definition(self, sub_query: SubQuery, context: Dict) -> List[Dict]:
        """Execute scale definition step (returns criteria, not search results)."""
        # This is a metadata step that defines criteria
        scale_criteria = {
            'small': {'max_employees': 50, 'max_revenue': 10000000},
            'medium': {'min_employees': 51, 'max_employees': 250, 'min_revenue': 10000001, 'max_revenue': 100000000},
            'large': {'min_employees': 251, 'min_revenue': 100000001}
        }
        
        # Store criteria in context for later use
        if 'medium scale' in sub_query.query.lower():
            self.context.company_filters['scale_criteria'] = scale_criteria['medium']
            self.context.company_filters['scale'] = 'Medium'
        elif 'small scale' in sub_query.query.lower():
            self.context.company_filters['scale_criteria'] = scale_criteria['small']
            self.context.company_filters['scale'] = 'Small'
        elif 'large scale' in sub_query.query.lower():
            self.context.company_filters['scale_criteria'] = scale_criteria['large']
            self.context.company_filters['scale'] = 'Large'
        
        # Return empty list as this is a definition step
        return []
    
    def execute_filter_query(self, sub_query: SubQuery, context: Dict) -> List[Dict]:
        """Execute filtering queries with context from previous steps."""
        search_params = self.map_subquery_to_search_params(sub_query, context)
        
        # Apply filters from context
        if 'scale' in self.context.company_filters:
            search_params['filter_scale'] = self.context.company_filters['scale']
        
        # If we have previous company results, we might need to filter further
        if context['previous_results']:
            # Execute search and then filter based on previous results
            results = self.search_api.search(**search_params)
            
            # Filter based on previous step results if needed
            if sub_query.dependencies:
                previous_company_ids = set()
                for dep_id in sub_query.dependencies:
                    if dep_id in context['previous_results']:
                        for result in context['previous_results'][dep_id]:
                            if 'company_ref_no' in result:
                                previous_company_ids.add(result['company_ref_no'])
                
                if previous_company_ids:
                    results = [r for r in results if r.get('company_ref_no') in previous_company_ids]
            
            return results
        else:
            return self.search_api.search(**search_params)
    
    def execute_product_listing(self, sub_query: SubQuery, context: Dict) -> List[Dict]:
        """Execute product listing queries based on filtered companies."""
        # Get companies from previous steps
        company_ids = set()
        for dep_id in sub_query.dependencies:
            if dep_id in context['previous_results']:
                for result in context['previous_results'][dep_id]:
                    if 'company_ref_no' in result:
                        company_ids.add(result['company_ref_no'])
        
        if not company_ids:
            logger.warning("No companies found from previous steps for product listing")
            return []
        
        # Search for products, then filter by company IDs
        search_params = self.map_subquery_to_search_params(sub_query, context)
        all_results = self.search_api.search(**search_params)
        
        # Filter results to only include companies from previous steps
        filtered_results = [r for r in all_results if r.get('company_ref_no') in company_ids]
        
        return filtered_results
    
    def execute_combination_query(self, sub_query: SubQuery, context: Dict) -> List[Dict]:
        """Execute combination queries that merge results from multiple steps."""
        if not sub_query.dependencies:
            return []
        
        # Get results from all dependency steps
        result_sets = []
        for dep_id in sub_query.dependencies:
            if dep_id in context['previous_results']:
                result_sets.append(context['previous_results'][dep_id])
        
        if not result_sets:
            return []
        
        # Intersect results (companies that meet all criteria)
        return self.aggregator.intersect_companies(result_sets)
    
    def map_subquery_to_search_params(self, sub_query: SubQuery, context: Dict) -> Dict[str, Any]:
        """Map sub-query to CompanySearchAPI search parameters."""
        params = {
            'query': sub_query.query,
            'top_k': 50  # Get more results for intermediate steps
        }
        
        # Extract filters from query text
        query_lower = sub_query.query.lower()
        
        # Scale filters
        if 'medium scale' in query_lower:
            params['filter_scale'] = 'Medium'
        elif 'small scale' in query_lower:
            params['filter_scale'] = 'Small'
        elif 'large scale' in query_lower:
            params['filter_scale'] = 'Large'
        
        # Industry filters
        if 'electrical' in query_lower:
            params['filter_industry'] = 'electrical'
        elif 'aerospace' in query_lower:
            params['filter_industry'] = 'aerospace'
        elif 'software' in query_lower:
            params['filter_industry'] = 'software'
        elif 'manufacturing' in query_lower:
            params['filter_industry'] = 'manufacturing'
        
        # Location filters
        if 'karnataka' in query_lower:
            params['filter_country'] = 'India'  # Assuming state filtering maps to country
        
        # Apply context filters
        if 'filters' in context:
            for key, value in context['filters'].items():
                if key.startswith('filter_') and key not in params:
                    params[key] = value
        
        return params
    
    def aggregate_final_results(self, query_plan: QueryPlan) -> List[Dict]:
        """Aggregate results based on query plan type and execution order."""
        if not query_plan.execution_order:
            return []
        
        if query_plan.plan_type == QueryType.SEQUENTIAL:
            # Return results from final step
            final_step_id = query_plan.execution_order[-1]
            results = self.context.step_results.get(final_step_id, [])
            
            # Re-rank by relevance to original query
            if results:
                results = self.aggregator.rank_by_relevance(results, query_plan.original_query)
            
            return results
        
        elif query_plan.plan_type == QueryType.COMPOUND:
            # Intersect results from multiple criteria
            all_results = []
            for step_id in query_plan.execution_order:
                if step_id != 'combine_results' and step_id in self.context.step_results:
                    step_results = self.context.step_results[step_id]
                    if step_results:  # Only include non-empty results
                        all_results.append(step_results)
            
            if all_results:
                intersected = self.aggregator.intersect_companies(all_results)
                return self.aggregator.rank_by_relevance(intersected, query_plan.original_query)
            else:
                return []
        
        elif query_plan.plan_type == QueryType.PARALLEL:
            # Union results from parallel queries
            all_results = []
            for step_id in query_plan.execution_order:
                if step_id in self.context.step_results:
                    all_results.extend(self.context.step_results[step_id])
            
            # Remove duplicates based on company_ref_no
            seen_companies = set()
            unique_results = []
            for result in all_results:
                company_id = result.get('company_ref_no')
                if company_id and company_id not in seen_companies:
                    seen_companies.add(company_id)
                    unique_results.append(result)
            
            return self.aggregator.rank_by_relevance(unique_results, query_plan.original_query)
        
        else:
            # Simple query - return results from the single step
            if query_plan.execution_order:
                step_id = query_plan.execution_order[0]
                return self.context.step_results.get(step_id, [])
            else:
                return []
